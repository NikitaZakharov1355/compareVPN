import { Transform, Duplex, Readable, type Writable } from 'node:stream';
export type StreamFilterCallback<O extends Partial<StreamFilterOptions>, T> = ((item: StreamFilterItem<O, T>, encoding: Parameters<Transform['_transform']>[1] | undefined, cb: (filtered: boolean) => void) => void) | ((item: StreamFilterItem<O, T>, encoding?: Parameters<Transform['_transform']>[1]) => Promise<boolean>);
export type StreamFilterOptions = {
    passthrough: boolean;
    restore: boolean;
    objectMode: boolean;
};
export type StreamFilterRestore<O extends Partial<StreamFilterOptions>> = O extends {
    passthrough: true;
} ? Duplex : O extends {
    restore: true;
} ? Readable : null;
export type StreamFilterItem<O extends Partial<StreamFilterOptions>, T> = O extends {
    objectMode: true;
} ? T : Buffer;
/** Filter piped in streams according to the given `filterCallback`. */
declare class StreamFilter<T, O extends Partial<StreamFilterOptions>> extends Transform {
    restore: StreamFilterRestore<O>;
    private _filterCallback;
    private _options;
    private _filterStreamEnded;
    private _restoreStreamCallback;
    private _restoreManager;
    /**
     * Options are passed in as is in the various stream instances spawned by this
     *  module. So, to use the objectMode, simply pass in the `options.objectMode`
     *  value set to `true`.
     * @param {Function} filterCallback    Callback applying the filters
     * @param {Object} options           Filtering options
     * @param {boolean} options.passthrough
     * Set to `true`, this option changes the restore stream nature from a readable
     *  stream to a passthrough one, allowing you to reuse the filtered chunks in an
     *  existing pipeline.
     * @param {boolean} options.restore
     * Set to `true`, this option create a readable stream allowing you to use the
     *  filtered chunks elsewhere. The restore stream is exposed in the `FilterStream`
     *  instance as a `restore` named property.
     * @return {StreamFilter}                 The filtering stream
     */
    constructor(filterCallback: StreamFilterCallback<O, T>, options?: O);
    _transform(chunk: StreamFilterItem<O, T>, encoding: Parameters<Writable['write']>[1], done: () => void): Promise<void>;
    _flush(done: () => void): void;
}
/**
 * Utility function if you prefer a functional way of using this lib
 * @param filterCallback
 * @param options
 * @returns Stream
 */
export declare function filterStream<O extends Partial<StreamFilterOptions>, T>(filterCallback: StreamFilterCallback<O, T>, options?: O): StreamFilter<T, O>;
export { StreamFilter };
