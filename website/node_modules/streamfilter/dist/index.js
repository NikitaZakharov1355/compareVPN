'use strict';
import { Transform, Duplex, Readable } from 'node:stream';
import { YError } from 'yerror';
const DEFAULT_OPTIONS = {
    restore: false,
    objectMode: false,
    passthrough: false,
};
/** Filter piped in streams according to the given `filterCallback`. */
class StreamFilter extends Transform {
    restore;
    _filterCallback;
    _options = DEFAULT_OPTIONS;
    _filterStreamEnded = false;
    _restoreStreamCallback = null;
    _restoreManager;
    /**
     * Options are passed in as is in the various stream instances spawned by this
     *  module. So, to use the objectMode, simply pass in the `options.objectMode`
     *  value set to `true`.
     * @param {Function} filterCallback    Callback applying the filters
     * @param {Object} options           Filtering options
     * @param {boolean} options.passthrough
     * Set to `true`, this option changes the restore stream nature from a readable
     *  stream to a passthrough one, allowing you to reuse the filtered chunks in an
     *  existing pipeline.
     * @param {boolean} options.restore
     * Set to `true`, this option create a readable stream allowing you to use the
     *  filtered chunks elsewhere. The restore stream is exposed in the `FilterStream`
     *  instance as a `restore` named property.
     * @return {StreamFilter}                 The filtering stream
     */
    constructor(filterCallback, options = DEFAULT_OPTIONS) {
        super({
            objectMode: !!options.objectMode,
        });
        this._options = {
            ...DEFAULT_OPTIONS,
            ...options,
            passthrough: (options.restore && options.passthrough) || false,
        };
        // filter callback is required
        if (!(filterCallback instanceof Function)) {
            throw new YError('E_BAD_FILTER_CALLBACK', typeof filterCallback);
        }
        this._filterCallback = filterCallback;
        // Creating the restored stream if necessary
        if (options.passthrough === true) {
            this.restore = new Duplex({
                objectMode: this._options.objectMode,
                write: (chunk, encoding, done) => {
                    this._restoreManager?.programPush(chunk, encoding, done);
                },
            });
            this._restoreManager = createReadStreamBackpressureManager(this.restore);
            this.restore.on('finish', () => {
                this._restoreStreamCallback = () => {
                    this._restoreManager?.programPush(null, undefined, () => { });
                };
                if (this._filterStreamEnded) {
                    this._restoreStreamCallback();
                }
            });
        }
        else if (options.restore === true) {
            this.restore = new Readable(options);
            this._restoreManager = createReadStreamBackpressureManager(this.restore);
        }
        else {
            this.restore = null;
            this._restoreManager = null;
        }
    }
    async _transform(chunk, encoding, done) {
        const cb = (filter) => {
            if (!filter) {
                this.push(chunk, encoding);
                done();
                return;
            }
            if (this._options.restore) {
                this._restoreManager?.programPush(chunk, encoding, () => {
                    done();
                });
                return;
            }
            done();
        };
        const result = this._filterCallback(chunk, encoding, cb);
        if (result instanceof Promise) {
            cb(await result);
        }
    }
    _flush(done) {
        this._filterStreamEnded = true;
        done();
        if (this._options.restore) {
            if (!this._options.passthrough) {
                this._restoreManager?.programPush(null, undefined, () => {
                    done();
                });
            }
            else if (this._restoreStreamCallback) {
                this._restoreStreamCallback();
            }
        }
    }
}
// Utils to manage readable stream backpressure
function createReadStreamBackpressureManager(readableStream) {
    const manager = {
        waitPush: true,
        programmedPushs: [],
        programPush: function programPush(chunk, encoding, done) {
            // Store the current write
            manager.programmedPushs.push([chunk, encoding, done]);
            // Need to be async to avoid nested push attempts
            // Program a push attempt
            setImmediate(manager.attemptPush);
            // Let's say we're ready for a read
            readableStream.emit('readable');
            readableStream.emit('drain');
        },
        attemptPush: function attemptPush() {
            let nextPush;
            if (manager.waitPush) {
                if (manager.programmedPushs.length) {
                    nextPush = manager.programmedPushs.shift();
                    manager.waitPush = readableStream.push(nextPush[0], nextPush[1]);
                    nextPush[2]();
                }
            }
            else {
                setImmediate(() => {
                    // Need to be async to avoid nested push attempts
                    readableStream.emit('readable');
                });
            }
        },
    };
    // Patch the readable stream to manage reads
    readableStream._read = function streamFilterRestoreRead() {
        manager.waitPush = true;
        // Need to be async to avoid nested push attempts
        setImmediate(manager.attemptPush);
    };
    return manager;
}
/**
 * Utility function if you prefer a functional way of using this lib
 * @param filterCallback
 * @param options
 * @returns Stream
 */
export function filterStream(filterCallback, options = DEFAULT_OPTIONS) {
    return new StreamFilter(filterCallback, options);
}
export { StreamFilter };
//# sourceMappingURL=index.js.map